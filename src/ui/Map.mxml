<?xml version="1.0"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
         xmlns:s="library://ns.adobe.com/flex/spark"
         creationComplete="onCreationComplete(event)"
         middleMouseDown="onMouseDown(event)"
         mouseChildren="false"
         doubleClickEnabled="true"
         doubleClick="onDoubleClick(event)">
    <fx:Script><![CDATA[
        import com.greensock.TweenLite;

        import events.PayloadEvent;

        import global.Color;
        import global.Draw;
        import global.Signal;
        import global.Util;

        import logic.Layer;
        import logic.Model;
        import logic.graph.Cell;
        import logic.graph.Edge;

        import managers.TaskManager;

        import mx.core.UIComponent;
        import mx.events.FlexEvent;
        import mx.events.ResizeEvent;

        // Singletons
        private var signal:Signal;
        private var model:Model;

        public var isDragging:Boolean = false;
        public var zoomLevel:Number = 1;
        private var hideBitmapLayersCountdown:Timer;

        private var mapLayers:Object = {};
        private var dragPoint:Point;
        private var initialDragPoint:Point;
        private var zoomLevels:Array = [.25, .5, .67, .8, .9, 1, 1.1, 1.25, 1.5, 1.75, 2, 2.5, 3];
        private var keepInBitmapMode:Boolean = false;

        private function onCreationComplete(event:FlexEvent):void
        {
            signal = Signal.instance;
            model = Model.instance;

            hideBitmapLayersCountdown = new Timer(500, 1);
            hideBitmapLayersCountdown.addEventListener(TimerEvent.TIMER_COMPLETE, function (timerEvent:TimerEvent):void
            {
                hideBitmapLayers();
            });

            addEventListeners();

            centerMap();
        }

        private function addEventListeners():void
        {
            systemManager.stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMove);
            systemManager.stage.addEventListener(MouseEvent.MIDDLE_MOUSE_UP, onMouseUp);
            systemManager.stage.addEventListener(Event.MOUSE_LEAVE, onMouseUp);

            addEventListener(MouseEvent.CLICK, onClick);
            addEventListener(MouseEvent.MOUSE_WHEEL, onScroll);

            signal.addEventListener(PayloadEvent.INITIALIZE, onInitializeUI);
            signal.addEventListener(PayloadEvent.ZOOM_IN, onZoomIn);
            signal.addEventListener(PayloadEvent.ZOOM_OUT, onZoomOut);
            signal.addEventListener(PayloadEvent.MOVE_MAP_TO_CENTER, onMoveMapToCenter);
            signal.addEventListener(PayloadEvent.DRAW, onDraw);
        }

        private function onClick(event:MouseEvent):void
        {
            var p:Point = new Point(mapLayerGroup.mouseX, mapLayerGroup.mouseY);
            signal.dispatchEvent(new PayloadEvent(PayloadEvent.MAP_CLICK, p));
        }

        private function onDraw(event:Event):void
        {
            trace("Map:onDraw");

            var layersToDraw:Array = TaskManager.instance.currentTask.layers;
            for each (var layer:String in layersToDraw)
            {
                switch (layer)
                {
                    case Layer.POINTS:
                        drawPoints();
                        break;
                    case Layer.VORONOI:
                        drawVoronoi();
                        break;
                    case Layer.DELAUNAY:
                        drawDelaunay();
                        break;
                }
            }
        }

        public function drawPoints():void
        {
            trace("Map:drawPoints");
            var c:UIComponent = getMapLayer(Layer.POINTS);
            while (c.numChildren > 0)
                c.removeChildAt(0);
            var spr:Sprite = new Sprite();
            c.addChild(spr);
            var g:Graphics = spr.graphics;

            for each (var p:Point in model.points)
            {
                g.beginFill(0xffffff);
                g.drawCircle(p.x, p.y, 2);
                g.endFill();
            }

            cacheLayer(c);
        }

        public function drawVoronoi():void
        {
            trace("Map:drawVoronoi");
            var c:UIComponent = getMapLayer(Layer.VORONOI);
            while (c.numChildren > 0)
                c.removeChildAt(0);
            var spr:Sprite = new Sprite();
            c.addChild(spr);
            var g:Graphics = spr.graphics;
            g.lineStyle(1, Color.textLow);
            g.drawRect(0, 0, 1999, 999);

            for each (var cell:Cell in model.cells)
                for each (var edge:Edge in cell.edges)
                    if (edge.v0 && edge.v1)
                        Draw.drawLine(g, edge.v0.point, edge.v1.point, Color.textLow);

            cacheLayer(c);
        }

        public function drawDelaunay():void
        {
            trace("Map:drawDelaunay");
            var c:UIComponent = getMapLayer(Layer.DELAUNAY);
            while (c.numChildren > 0)
                c.removeChildAt(0);
            var spr:Sprite = new Sprite();
            c.addChild(spr);
            var g:Graphics = spr.graphics;

            for each (var cell:Cell in model.cells)
                for each (var edge:Edge in cell.edges)
                    if (edge.d0 && edge.d1)
                        Draw.drawLine(g, edge.d0.point, edge.d1.point, Color.pacificBlue);

            cacheLayer(c);
        }

        private function onInitializeUI(event:PayloadEvent):void
        {
            // Dispatches initial signals to UI
            signal.dispatchEvent(new PayloadEvent(PayloadEvent.MAP_ZOOM, zoomLevel));
            signal.dispatchEvent(new PayloadEvent(PayloadEvent.MAP_MOUSE_MOVE, new Point(mapLayerGroup.mouseX, mapLayerGroup.mouseY)));
        }

        private function onZoomIn(event:PayloadEvent):void
        {
            zoomIn();
        }

        private function onZoomOut(event:PayloadEvent):void
        {
            zoomOut();
        }

        private function onMoveMapToCenter(event:PayloadEvent):void
        {
            centerMap();
        }

        private function showBitmapLayers():void
        {
            keepInBitmapMode = true;

            for each (var c:UIComponent in mapLayers)
            {
                for (var i:int = 0; i < c.numChildren; i++)
                    c.getChildAt(i).visible = false;

                var bmp:Bitmap = Bitmap(c.getChildByName("bmp"));
                if (bmp != null)
                    bmp.visible = true;
            }
        }

        private function hideBitmapLayers():void
        {
            if (keepInBitmapMode || zoomLevel <= 1)
                return;

            for each (var c:UIComponent in mapLayers)
            {
                for (var i:int = 0; i < c.numChildren; i++)
                    c.getChildAt(i).visible = true;

                var bmp:Bitmap = Bitmap(c.getChildByName("bmp"));
                if (bmp != null)
                    bmp.visible = false;
            }
        }

        private function delayHideBitmapLayers():void
        {
            hideBitmapLayersCountdown.reset();
            hideBitmapLayersCountdown.start();
        }

        public function getMapLayer(id:String):UIComponent
        {
            if (!mapLayers.hasOwnProperty(id))
            {
                var c:UIComponent = mapLayers[id] = new UIComponent();
                c.cacheAsBitmap = true;
                mapLayerGroup.addElement(c);
            }

            return mapLayers[id];
        }

        private function onMouseMove(event:MouseEvent):void
        {
            if (dragPoint)
            {
                if (!isDragging)
                    showBitmapLayers();

                var newX:Number = systemManager.stage.mouseX - dragPoint.x;
                var newY:Number = systemManager.stage.mouseY - dragPoint.y;
                var distance:Point = new Point(newX, newY);
                isDragging = true;

                dragPoint = new Point(systemManager.stage.mouseX, systemManager.stage.mouseY);
                mapLayerGroup.x += distance.x;
                mapLayerGroup.y += distance.y;
            }

            var e:PayloadEvent = new PayloadEvent(PayloadEvent.MAP_MOUSE_MOVE, new Point(mapLayerGroup.mouseX, mapLayerGroup.mouseY));
            signal.dispatchEvent(e);
        }

        private function onMouseDown(event:MouseEvent):void
        {
            isDragging = false;
            dragPoint = new Point(event.stageX, event.stageY);
            initialDragPoint = dragPoint.clone();
        }

        private function onMouseUp(event:Event):void
        {
            callLater(function ():void
            {
                isDragging = false;

                keepInBitmapMode = false;
                delayHideBitmapLayers();
            });
            dragPoint = null;
        }

        private function onScroll(event:MouseEvent):void
        {
            if (event.delta > 0)
                zoomIn();
            if (event.delta < 0)
                zoomOut();
        }

        public function zoomIn():void
        {
            var previousZoomLevel:Number = zoomLevel;

            var zoomLevelIndex:int = zoomLevels.indexOf(zoomLevel);
            if (zoomLevelIndex < 0)
                zoomLevel = 0;
            else if (zoomLevelIndex + 1 < zoomLevels.length)
                zoomLevel = zoomLevels[zoomLevelIndex + 1];

            if (zoomLevel == previousZoomLevel)
                return;

            validateZoom();
        }

        public function zoomOut():void
        {
            var zoomLevelIndex:int = zoomLevels.indexOf(zoomLevel);
            if (zoomLevelIndex < 0)
                zoomLevel = 1;
            else if (zoomLevelIndex > 0)
                zoomLevel = zoomLevels[zoomLevelIndex - 1];

            validateZoom();
        }

        public function centerMap():void
        {
            centerMapOnPoint(new Point(mapLayerGroup.width / 2, mapLayerGroup.height / 2));
        }

        private function validateZoom():void
        {
            // Get the viewport's center point
            var p:Point = new Point(width / 2, height / 2);
            p = mapLayerGroup.globalToLocal(localToGlobal(p));

            showBitmapLayers();
            TweenLite.to(mapLayerGroup, .2, {
                scaleX: zoomLevel, onUpdate: function ():void
                {
                    mapLayerGroup.scaleY = mapLayerGroup.scaleX;
                    centerMapOnPoint(p, false);
                }, onComplete: endZoom
            });
        }

        private function endZoom():void
        {
            keepInBitmapMode = false;
            delayHideBitmapLayers();

            signal.dispatchEvent(new PayloadEvent(PayloadEvent.MAP_ZOOM, zoomLevel))
        }

        private function centerMapOnPoint(p:Point, animate:Boolean = true):void
        {
            var v:Point = new Point(width / 2, height / 2);
            v = mapLayerGroup.globalToLocal(localToGlobal(v));

            var goal:Point = new Point();
            goal.x = mapLayerGroup.x + ((v.x - p.x) * mapLayerGroup.scaleX);
            goal.y = mapLayerGroup.y + ((v.y - p.y) * mapLayerGroup.scaleY);

            if (animate)
            {
                TweenLite.to(mapLayerGroup, .6, {x: goal.x, y: goal.y});
            } else
            {
                mapLayerGroup.x = goal.x;
                mapLayerGroup.y = goal.y;
            }
        }

        private function onDoubleClick(event:MouseEvent):void
        {
            centerMapOnPoint(new Point(mapLayerGroup.mouseX, mapLayerGroup.mouseY));
        }

        private function onLayerGroupContainerResize(event:ResizeEvent):void
        {
            var t:Object = event.target;
            t.height = (t.width / t.contentWidth) * t.contentHeight;
        }

        private static function cacheLayer(c:UIComponent):void
        {
            var bmpd:BitmapData = new BitmapData(2000, 1000, true, 0x000000);
            bmpd.draw(c);
            var bmp:Bitmap = new Bitmap(bmpd);
            bmp.name = "bmp";
            bmp.smoothing = true;

            c.addChild(bmp);
        }
        ]]></fx:Script>

    <s:Group id="layerGroupMask"
             width="100%"
             height="100%">
        <s:Rect width="100%"
                height="100%">
            <s:fill>
                <s:SolidColor color="{0xff0000}"/>
            </s:fill>
        </s:Rect>
    </s:Group>

    <s:VGroup id="layerGroupContainer"
              padding="15"
              includeInLayout="false"
              mask="{layerGroupMask}"
              resize="onLayerGroupContainerResize(event)">

        <s:Group id="mapLayerGroup"
                 width="2000"
                 height="1000">
        </s:Group>
    </s:VGroup>

</s:Group>
